# preview-env.yml - GitOps Preview Environments
#
# Automatically provisions an ephemeral preview environment for every
# non-main branch push, and destroys it when the branch is merged or deleted.
#
# If a Dockerfile exists at the repo root (or path specified in .idp/config.yml),
# the image is built, pushed to ECR, and deployed. Otherwise, the configured
# container_image (default: nginx:alpine) is used.
#
# Configuration is read from .idp/config.yml in the repository root.

name: Preview Environment

on:
  push:
    branches-ignore:
      - main
      - master

  pull_request:
    types: [closed]

  delete:
    # Triggered when a branch is deleted

permissions:
  id-token: write
  contents: write
  pull-requests: write
  actions: write

# Prevent duplicate destroy runs when both pull_request[closed] and delete
# fire for the same branch. The second run is cancelled instead of failing
# with a Terraform state lock conflict.
concurrency:
  group: preview-${{ github.event.pull_request.head.ref || github.event.ref || github.ref_name }}
  cancel-in-progress: true

env:
  STATE_BUCKET: mini-idp-terraform-state
  AWS_REGION: us-east-1

# -----------------------------------------------------------------
# Job 1: Setup â€” determine action, sanitize branch name, read config
# -----------------------------------------------------------------
jobs:
  setup:
    name: Setup
    runs-on: ubuntu-latest
    # Skip tag deletions (we only care about branch deletions)
    if: github.event.ref_type != 'tag'
    outputs:
      environment_name: ${{ steps.sanitize.outputs.environment_name }}
      action: ${{ steps.decide.outputs.action }}
      template: ${{ steps.config.outputs.template }}
      ttl: ${{ steps.config.outputs.ttl }}
      owner: ${{ steps.config.outputs.owner }}
      container_image: ${{ steps.config.outputs.container_image }}
      container_port: ${{ steps.config.outputs.container_port }}
      dockerfile: ${{ steps.config.outputs.dockerfile }}
      build_context: ${{ steps.config.outputs.build_context }}
      environment_variables: ${{ steps.config.outputs.environment_variables }}
      secret_variables: ${{ steps.config.outputs.secret_variables }}
      schedule_expression: ${{ steps.config.outputs.schedule_expression }}
      s3_bucket_arn: ${{ steps.config.outputs.s3_bucket_arn }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        if: github.event_name == 'push'

      - name: Determine branch name
        id: branch
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "push" ]]; then
            BRANCH="${{ github.ref_name }}"
          elif [[ "${{ github.event_name }}" == "delete" ]]; then
            BRANCH="${{ github.event.ref }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH="${{ github.event.pull_request.head.ref }}"
          fi

          echo "branch=${BRANCH}" >> "$GITHUB_OUTPUT"
          echo "Branch: ${BRANCH}"

      - name: Sanitize branch name to environment name
        id: sanitize
        run: |
          set -euo pipefail

          BRANCH="${{ steps.branch.outputs.branch }}"

          # Remove common prefixes
          CLEAN=$(echo "$BRANCH" | sed -E 's#^(feature|bugfix|hotfix|fix|chore|release)/##')

          # Lowercase
          CLEAN=$(echo "$CLEAN" | tr '[:upper:]' '[:lower:]')

          # Replace non-alphanumeric (except hyphens) with hyphens
          CLEAN=$(echo "$CLEAN" | sed 's/[^a-z0-9-]/-/g')

          # Collapse multiple consecutive hyphens
          CLEAN=$(echo "$CLEAN" | sed 's/-\{2,\}/-/g')

          # Trim leading/trailing hyphens
          CLEAN=$(echo "$CLEAN" | sed 's/^-//; s/-$//')

          # Truncate to 24 chars (32 - len("preview-"))
          CLEAN=$(echo "$CLEAN" | cut -c1-24)

          # Trim trailing hyphen after truncation
          CLEAN=$(echo "$CLEAN" | sed 's/-$//')

          ENV_NAME="preview-${CLEAN}"

          echo "environment_name=${ENV_NAME}" >> "$GITHUB_OUTPUT"
          echo "Environment name: ${ENV_NAME}"

      - name: Read .idp/config.yml or use defaults
        id: config
        run: |
          set -euo pipefail

          CONFIG_FILE=".idp/config.yml"

          if [[ "${{ github.event_name }}" == "push" && -f "$CONFIG_FILE" ]]; then
            echo "Found $CONFIG_FILE, reading configuration..."

            # Install yq for YAML parsing
            if ! command -v yq &> /dev/null; then
              wget -qO /usr/local/bin/yq \
                https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
              chmod +x /usr/local/bin/yq
            fi

            TEMPLATE=$(yq eval '.template // "api-service"' "$CONFIG_FILE")
            TTL=$(yq eval '.ttl // "7d"' "$CONFIG_FILE")
            CONTAINER_IMAGE=$(yq eval '.container_image // "nginx:alpine"' "$CONFIG_FILE")
            CONTAINER_PORT=$(yq eval '.container_port // 80' "$CONFIG_FILE")
            DOCKERFILE=$(yq eval '.dockerfile // ""' "$CONFIG_FILE")
            BUILD_CONTEXT=$(yq eval '.build_context // "."' "$CONFIG_FILE")
            ENV_VARS=$(yq eval -o=json '.environment // {}' "$CONFIG_FILE")
            SECRET_VARS=$(yq eval -o=json '.secrets // {}' "$CONFIG_FILE")
            SCHEDULE_EXPR=$(yq eval '.schedule_expression // ""' "$CONFIG_FILE")
            S3_BUCKET=$(yq eval '.s3_bucket_arn // ""' "$CONFIG_FILE")
          else
            echo "Using defaults (no config file or non-push event)..."
            TEMPLATE="api-service"
            TTL="7d"
            CONTAINER_IMAGE="nginx:alpine"
            CONTAINER_PORT="80"
            DOCKERFILE=""
            BUILD_CONTEXT="."
            ENV_VARS="{}"
            SECRET_VARS="{}"
            SCHEDULE_EXPR=""
            S3_BUCKET=""
          fi

          echo "template=${TEMPLATE}" >> "$GITHUB_OUTPUT"
          echo "ttl=${TTL}" >> "$GITHUB_OUTPUT"
          echo "container_image=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          echo "container_port=${CONTAINER_PORT}" >> "$GITHUB_OUTPUT"
          echo "dockerfile=${DOCKERFILE}" >> "$GITHUB_OUTPUT"
          echo "build_context=${BUILD_CONTEXT}" >> "$GITHUB_OUTPUT"
          echo "environment_variables=${ENV_VARS}" >> "$GITHUB_OUTPUT"
          echo "secret_variables=${SECRET_VARS}" >> "$GITHUB_OUTPUT"
          echo "schedule_expression=${SCHEDULE_EXPR}" >> "$GITHUB_OUTPUT"
          echo "s3_bucket_arn=${S3_BUCKET}" >> "$GITHUB_OUTPUT"
          echo "owner=${{ github.actor }}@users.noreply.github.com" >> "$GITHUB_OUTPUT"

          echo "Configuration:"
          echo "  Template: ${TEMPLATE}"
          echo "  TTL: ${TTL}"
          echo "  Image: ${CONTAINER_IMAGE}"
          echo "  Port: ${CONTAINER_PORT}"
          echo "  Dockerfile: ${DOCKERFILE:-auto-detect}"
          echo "  Build context: ${BUILD_CONTEXT}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: github.event_name == 'push'
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Decide action (provision / extend / destroy)
        id: decide
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"
          ENV_NAME="${{ steps.sanitize.outputs.environment_name }}"

          # Destroy on branch delete or PR close
          if [[ "$EVENT" == "delete" ]]; then
            echo "action=destroy" >> "$GITHUB_OUTPUT"
            echo "Action: destroy (branch deleted)"
            exit 0
          fi

          if [[ "$EVENT" == "pull_request" ]]; then
            echo "action=destroy" >> "$GITHUB_OUTPUT"
            echo "Action: destroy (PR closed)"
            exit 0
          fi

          # Push event â€” check if environment already exists
          METADATA_KEY="environments/${ENV_NAME}/metadata.json"
          if aws s3 cp "s3://${STATE_BUCKET}/${METADATA_KEY}" /tmp/existing-metadata.json 2>/dev/null; then
            STATUS=$(jq -r '.status // "unknown"' /tmp/existing-metadata.json)
            if [[ "$STATUS" == "active" ]]; then
              echo "action=extend" >> "$GITHUB_OUTPUT"
              echo "Action: extend (active environment found)"
              exit 0
            fi
          fi

          echo "action=provision" >> "$GITHUB_OUTPUT"
          echo "Action: provision (new environment)"

  # -----------------------------------------------------------------
  # Job 2: Build Image â€” build and push Docker image to ECR
  # -----------------------------------------------------------------
  build-image:
    name: Build Image
    needs: setup
    if: needs.setup.outputs.action == 'provision' || needs.setup.outputs.action == 'extend'
    runs-on: ubuntu-latest
    environment: production
    outputs:
      container_image: ${{ steps.resolve.outputs.container_image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine if Dockerfile exists
        id: check
        run: |
          set -euo pipefail
          DOCKERFILE="${{ needs.setup.outputs.dockerfile }}"

          # If dockerfile is explicitly set in config, use that path
          if [[ -n "$DOCKERFILE" ]]; then
            if [[ -f "$DOCKERFILE" ]]; then
              echo "has_dockerfile=true" >> "$GITHUB_OUTPUT"
              echo "dockerfile_path=${DOCKERFILE}" >> "$GITHUB_OUTPUT"
              echo "Found Dockerfile at configured path: ${DOCKERFILE}"
            else
              echo "::error::Configured dockerfile '${DOCKERFILE}' not found"
              exit 1
            fi
          # Otherwise, check for Dockerfile at repo root
          elif [[ -f "Dockerfile" ]]; then
            echo "has_dockerfile=true" >> "$GITHUB_OUTPUT"
            echo "dockerfile_path=Dockerfile" >> "$GITHUB_OUTPUT"
            echo "Found Dockerfile at repo root"
          else
            echo "has_dockerfile=false" >> "$GITHUB_OUTPUT"
            echo "No Dockerfile found, will use container_image from config"
          fi

      - name: Configure AWS credentials
        if: steps.check.outputs.has_dockerfile == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: steps.check.outputs.has_dockerfile == 'true'
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        if: steps.check.outputs.has_dockerfile == 'true'
        id: build
        run: |
          set -euo pipefail

          ECR_REGISTRY="${{ steps.ecr-login.outputs.registry }}"
          ECR_REPO="mini-idp-preview"
          ENV_NAME="${{ needs.setup.outputs.environment_name }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          IMAGE_TAG="${ENV_NAME}-${SHORT_SHA}"
          FULL_IMAGE="${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"

          BUILD_CONTEXT="${{ needs.setup.outputs.build_context }}"
          DOCKERFILE="${{ steps.check.outputs.dockerfile_path }}"

          echo "Building image: ${FULL_IMAGE}"
          echo "  Dockerfile: ${DOCKERFILE}"
          echo "  Context: ${BUILD_CONTEXT}"

          docker build \
            -t "${FULL_IMAGE}" \
            -f "${DOCKERFILE}" \
            --label "idp.environment=${ENV_NAME}" \
            --label "idp.commit=${{ github.sha }}" \
            --label "idp.branch=${{ github.ref_name }}" \
            "${BUILD_CONTEXT}"

          docker push "${FULL_IMAGE}"

          echo "image_uri=${FULL_IMAGE}" >> "$GITHUB_OUTPUT"
          echo "Image pushed: ${FULL_IMAGE}"

      - name: Resolve final container image
        id: resolve
        run: |
          set -euo pipefail
          if [[ "${{ steps.check.outputs.has_dockerfile }}" == "true" ]]; then
            echo "container_image=${{ steps.build.outputs.image_uri }}" >> "$GITHUB_OUTPUT"
          else
            echo "container_image=${{ needs.setup.outputs.container_image }}" >> "$GITHUB_OUTPUT"
          fi

  # -----------------------------------------------------------------
  # Job 3: Provision â€” create new preview environment
  # -----------------------------------------------------------------
  provision:
    name: Provision Preview
    needs: [setup, build-image]
    if: needs.setup.outputs.action == 'provision'
    uses: ./.github/workflows/provision.yml
    with:
      template: ${{ needs.setup.outputs.template }}
      environment_name: ${{ needs.setup.outputs.environment_name }}
      owner: ${{ needs.setup.outputs.owner }}
      ttl: ${{ needs.setup.outputs.ttl }}
      container_image: ${{ needs.build-image.outputs.container_image }}
      container_port: ${{ needs.setup.outputs.container_port }}
      schedule_expression: ${{ needs.setup.outputs.schedule_expression }}
      s3_bucket_arn: ${{ needs.setup.outputs.s3_bucket_arn }}
      environment_variables: ${{ needs.setup.outputs.environment_variables }}
      secret_variables: ${{ needs.setup.outputs.secret_variables }}
      acm_certificate_arn: ${{ vars.PREVIEW_ACM_CERT_ARN }}
      route53_zone_id: ${{ vars.PREVIEW_ZONE_ID }}
      preview_domain: ${{ vars.PREVIEW_DOMAIN }}
    secrets: inherit

  # -----------------------------------------------------------------
  # Job 4: Extend & Redeploy â€” update TTL and deploy latest code
  # -----------------------------------------------------------------
  extend:
    name: Extend & Redeploy
    needs: [setup, build-image]
    if: needs.setup.outputs.action == 'extend'
    uses: ./.github/workflows/provision.yml
    with:
      template: ${{ needs.setup.outputs.template }}
      environment_name: ${{ needs.setup.outputs.environment_name }}
      owner: ${{ needs.setup.outputs.owner }}
      ttl: ${{ needs.setup.outputs.ttl }}
      container_image: ${{ needs.build-image.outputs.container_image }}
      container_port: ${{ needs.setup.outputs.container_port }}
      schedule_expression: ${{ needs.setup.outputs.schedule_expression }}
      s3_bucket_arn: ${{ needs.setup.outputs.s3_bucket_arn }}
      environment_variables: ${{ needs.setup.outputs.environment_variables }}
      secret_variables: ${{ needs.setup.outputs.secret_variables }}
      acm_certificate_arn: ${{ vars.PREVIEW_ACM_CERT_ARN }}
      route53_zone_id: ${{ vars.PREVIEW_ZONE_ID }}
      preview_domain: ${{ vars.PREVIEW_DOMAIN }}
    secrets: inherit

  # -----------------------------------------------------------------
  # Job 5: Destroy â€” tear down preview environment
  # -----------------------------------------------------------------
  destroy:
    name: Destroy Preview
    needs: setup
    if: needs.setup.outputs.action == 'destroy'
    uses: ./.github/workflows/destroy.yml
    with:
      environment_name: ${{ needs.setup.outputs.environment_name }}
    secrets: inherit

  # -----------------------------------------------------------------
  # Job 6: Comment â€” post preview URL on associated PR
  # -----------------------------------------------------------------
  comment:
    name: Comment on PR
    needs: [setup, provision, extend]
    # Run after provision OR extend (if either succeeded)
    if: |
      always() &&
      needs.setup.outputs.action != 'destroy' &&
      (needs.provision.result == 'success' || needs.extend.result == 'success')
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Find associated PR and post comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ENV_NAME="${{ needs.setup.outputs.environment_name }}"
          ACTION="${{ needs.setup.outputs.action }}"

          # Find PR for this branch
          PR_NUMBER=$(gh pr list \
            --repo "${{ github.repository }}" \
            --head "${{ github.ref_name }}" \
            --json number \
            --jq '.[0].number // empty' 2>/dev/null || echo "")

          if [[ -z "$PR_NUMBER" ]]; then
            echo "No PR found for branch ${{ github.ref_name }}, skipping comment."
            exit 0
          fi

          echo "Found PR #${PR_NUMBER}"

          # Fetch environment details from S3
          METADATA_KEY="environments/${ENV_NAME}/metadata.json"
          OUTPUTS_KEY="environments/${ENV_NAME}/outputs.json"

          EXPIRES_AT="unknown"
          ENDPOINT="pending"
          TEMPLATE="${{ needs.setup.outputs.template }}"

          if aws s3 cp "s3://${STATE_BUCKET}/${METADATA_KEY}" /tmp/metadata.json 2>/dev/null; then
            EXPIRES_AT=$(jq -r '.expires_at // "unknown"' /tmp/metadata.json)
          fi

          if aws s3 cp "s3://${STATE_BUCKET}/${OUTPUTS_KEY}" /tmp/outputs.json 2>/dev/null; then
            ENDPOINT=$(jq -r '.endpoint.value // .endpoint // "pending"' /tmp/outputs.json)
          fi

          if [[ "$ACTION" == "provision" ]]; then
            STATUS_EMOJI="ðŸš€"
            STATUS_TEXT="created"
          else
            STATUS_EMOJI="ðŸ”„"
            STATUS_TEXT="updated (TTL extended)"
          fi

          COMMENT_BODY="${STATUS_EMOJI} **Preview Environment ${STATUS_TEXT}**

          | | |
          |---|---|
          | **Environment** | \`${ENV_NAME}\` |
          | **URL** | ${ENDPOINT} |
          | **Template** | \`${TEMPLATE}\` |
          | **Expires** | ${EXPIRES_AT} |

          > This environment is automatically destroyed when this PR is merged or the branch is deleted.
          > TTL is extended on every push."

          # Check for existing preview comment to update instead of duplicate
          EXISTING_COMMENT_ID=$(gh api \
            "repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
            --jq '.[] | select(.body | contains("Preview Environment")) | .id' \
            2>/dev/null | head -1 || echo "")

          if [[ -n "$EXISTING_COMMENT_ID" ]]; then
            echo "Updating existing comment ${EXISTING_COMMENT_ID}"
            gh api \
              --method PATCH \
              "repos/${{ github.repository }}/issues/comments/${EXISTING_COMMENT_ID}" \
              -f body="${COMMENT_BODY}"
          else
            echo "Creating new comment on PR #${PR_NUMBER}"
            gh pr comment "${PR_NUMBER}" \
              --repo "${{ github.repository }}" \
              --body "${COMMENT_BODY}"
          fi

  # -----------------------------------------------------------------
  # Job 7: Dashboard â€” update ENVIRONMENTS.md on main
  # -----------------------------------------------------------------
  dashboard:
    name: Update Dashboard
    needs: [setup, provision, extend, destroy]
    if: |
      always() &&
      (needs.provision.result == 'success' ||
       needs.extend.result == 'success' ||
       needs.destroy.result == 'success')
    uses: ./.github/workflows/update-dashboard.yml
    secrets: inherit
