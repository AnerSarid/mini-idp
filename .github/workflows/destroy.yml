name: Destroy Environment

on:
  workflow_dispatch:
    inputs:
      environment_name:
        description: "Name of the environment to destroy"
        required: true
        type: string

  workflow_call:
    inputs:
      environment_name:
        description: "Name of the environment to destroy"
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  STATE_BUCKET: mini-idp-terraform-state
  AWS_REGION: us-east-1

jobs:
  destroy:
    name: Destroy - ${{ inputs.environment_name }}
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_wrapper: false

      - name: Read environment metadata from S3
        id: metadata
        run: |
          set -euo pipefail
          METADATA_KEY="environments/${{ inputs.environment_name }}/metadata.json"

          if ! aws s3 cp "s3://${STATE_BUCKET}/${METADATA_KEY}" metadata.json; then
            echo "::error::Metadata not found for '${{ inputs.environment_name }}'."
            exit 1
          fi

          TEMPLATE=$(jq -r '.template' metadata.json)
          if [[ -z "$TEMPLATE" || "$TEMPLATE" == "null" ]]; then
            echo "::error::Could not determine template from metadata."
            exit 1
          fi

          echo "template=${TEMPLATE}" >> "$GITHUB_OUTPUT"

      - name: Prepare tfvars for destroy
        id: tfvars
        run: |
          set -euo pipefail
          TEMPLATE="${{ steps.metadata.outputs.template }}"
          TFVARS_FILE="infrastructure/environments/${{ inputs.environment_name }}.tfvars"

          # If the tfvars doesn't exist in the repo, generate one from metadata
          if [[ ! -f "$TFVARS_FILE" ]]; then
            echo "Generating fallback tfvars from metadata..."
            mkdir -p "$(dirname "$TFVARS_FILE")"
            OWNER=$(jq -r '.owner // "unknown"' metadata.json)
            TTL=$(jq -r '.ttl // "7d"' metadata.json)
            CREATED_AT=$(jq -r '.created_at // "2000-01-01T00:00:00Z"' metadata.json)
            EXPIRES_AT=$(jq -r '.expires_at // "2000-01-01T00:00:00Z"' metadata.json)

            cat > "${TFVARS_FILE}" <<EOF
          environment_name = "${{ inputs.environment_name }}"
          owner            = "${OWNER}"
          ttl              = "${TTL}"
          created_at       = "${CREATED_AT}"
          expires_at       = "${EXPIRES_AT}"
          EOF

            if [[ "$TEMPLATE" == "scheduled-worker" ]]; then
              cat >> "${TFVARS_FILE}" <<EOF
          schedule_expression = "rate(1 hour)"
          s3_bucket_arn       = ""
          EOF
            fi

            # DNS variables for ALB-based templates
            if [[ "$TEMPLATE" == "api-service" || "$TEMPLATE" == "api-database" ]]; then
              ACM_ARN=$(jq -r '.acm_certificate_arn // ""' metadata.json)
              ZONE_ID=$(jq -r '.route53_zone_id // ""' metadata.json)
              PREVIEW_DOMAIN=$(jq -r '.preview_domain // ""' metadata.json)
              cat >> "${TFVARS_FILE}" <<EOF
          acm_certificate_arn = "${ACM_ARN}"
          route53_zone_id     = "${ZONE_ID}"
          preview_domain      = "${PREVIEW_DOMAIN}"
          EOF
            fi

            # Container image (if a custom image was deployed)
            CONTAINER_IMAGE=$(jq -r '.container_image // ""' metadata.json)
            if [[ -n "$CONTAINER_IMAGE" && "$CONTAINER_IMAGE" != "nginx:alpine" ]]; then
              echo "container_image = \"${CONTAINER_IMAGE}\"" >> "${TFVARS_FILE}"
            fi

            sed -i 's/^          //' "${TFVARS_FILE}"
          fi

          echo "tfvars_file=${TFVARS_FILE}" >> "$GITHUB_OUTPUT"

      - name: Tofu init
        working-directory: infrastructure/templates/${{ steps.metadata.outputs.template }}
        run: |
          tofu init -input=false \
            -backend-config="key=environments/${{ inputs.environment_name }}/terraform.tfstate"

      - name: Tofu destroy
        working-directory: infrastructure/templates/${{ steps.metadata.outputs.template }}
        run: |
          tofu destroy \
            -var-file="${{ github.workspace }}/${{ steps.tfvars.outputs.tfvars_file }}" \
            -auto-approve \
            -input=false

      - name: Clean up S3 artifacts
        run: |
          set -euo pipefail
          aws s3 rm "s3://${STATE_BUCKET}/environments/${{ inputs.environment_name }}/" --recursive

      - name: Clean up ECR images
        continue-on-error: true
        run: |
          set -euo pipefail

          ENV_NAME="${{ inputs.environment_name }}"
          ECR_REPO="mini-idp-preview"

          echo "Cleaning up ECR images tagged with '${ENV_NAME}-*'..."

          # List images matching this environment's tag prefix
          IMAGE_IDS=$(aws ecr list-images \
            --repository-name "${ECR_REPO}" \
            --filter tagStatus=TAGGED \
            --query "imageIds[?starts_with(imageTag, '${ENV_NAME}-')]" \
            --output json 2>/dev/null || echo "[]")

          if [[ "$IMAGE_IDS" == "[]" || -z "$IMAGE_IDS" ]]; then
            echo "No ECR images found for environment '${ENV_NAME}'."
            exit 0
          fi

          IMAGE_COUNT=$(echo "$IMAGE_IDS" | jq 'length')
          echo "Found ${IMAGE_COUNT} image(s) to delete."

          aws ecr batch-delete-image \
            --repository-name "${ECR_REPO}" \
            --image-ids "$IMAGE_IDS"

          echo "ECR images cleaned up successfully."
